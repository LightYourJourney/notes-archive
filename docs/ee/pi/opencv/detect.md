# 图片形状检测

<a name="_page34_x72.00_y588.00"></a>图片中的不同的形状通常依赖于色彩、强度上的变化来区分，而计算机要识别不同的形状依赖于色彩、强度的变化信息的提取，在图片处理中该类信息采用梯度 (gradient) 来描述。梯度信息是图片中重要信 息，关于梯度的计算及应用是图形检测的基础。在进行图片形状检测之前，通常需要对图片做颜色变化、二 值化、滤波等预处理。

1. 图片滤波及梯度运算
- 图片滤波运算

  在计算图片的梯度前，采用滤波方法降低噪声带来的影响。对图像的滤波处理类似信号处理中的卷 积运算，主要区别在于关于图片的滤波是对二维数据的运算，图像的滤波处理能够有效消除图片中

30 第四章 OPENCV 基础

的噪声，式 [4.1](#_page35_x265.29_y147.52) 为一个 3X3 的归一化平滑滤波器，OpenCV 中提供了 filter2D()，Blur()等滤波 函数，深入理解图像处理中的滤波运算也是图像处理的基础。OpenCV 提供了许多轮廓检测函数，如 Canny(),findContours()等。

- 

1 1 1

<a name="_page35_x265.29_y147.52"></a>K = 19  1 1 1  (4.1)



1 1 1

- 图片的梯度（ gradient）计算

  在 OpenCV 中对于图片梯度的计算也可以看做是一种特殊的滤波运算，OpenCV 中提供多种梯度 运算函数，如 Sobel()、Scharr()、Laplacian() 等，Sobel() 函数能够获得指定方向上的图像的梯度值，

  Scharr() 是对 Sobel() 的进一步优化。Laplacian() 方法计算两个方向上的梯度 ∆src = δδ2xsr2c + δδ2ysr2c ，其核函数 [^1]如式 [4.2](#_page35_x277.16_y307.66) 所示。通过计算图像的梯度来实现对图像的边检测。

- 

0 1 0

<a name="_page35_x277.16_y307.66"></a> 1 − 4 1  (4.2)



0  1 0
2. 图片形状检测

对于图片形状检测，根据实际应用场景及检测需求，主要可以基于色彩、形状来进行识别及检测。

Hough 变换支持对规则的形状如直线、圆形检测，对于复杂形状的检测 OpenCV 提供了 findContours()来 完成不规则形状的识别。下面分别介绍其基本原理及用法。

- 特殊形状检测

  对于特殊形状如直线、圆形，也可以采用特殊的检测方法进行检测。如 OpenCV 中采用 Hough 变换 对图形中的特殊形状（直线、圆形等）进行检测。Hough 变换的基本原理就是将图片中点变换到另外 一个坐标系，如图 [4.3](#_page36_x72.00_y64.23) 所示，对于图中点依次进行 Hough 变换 (r,θ)，每条经过点 (x,y) 的直线都有 唯一的 (r,θ) 与之对应，随着经过该点的直线的斜率的变化 (r,θ) 满足 sin()函数。对图片中的点均

  进行 Hough 变化，可以得出同在一条直线上点穿过 r0,θ0 的次数最多，由此可以判断同在一条直线

  上的点。

  类似的对于圆形的的识别，根据圆形满足式 (x − x0)2 + ( y − y0)2 = r2, 其中 (x0,y0) 为圆心 ,r 为圆 的半径。对于圆形的识别，首先是在已知半径 r0 下通过对圆的交点进行计次，根据最大的计次数来 确定圆心点，如图 [4.4](#_page36_x72.00_y272.91) ；根据确定的圆心的像素点，再确定半径。

  从 Hough 变换的基本原理看出，Hough 变换采用不同空间的映射完成特殊形状的检测，但是带来了 巨大的运算量，为进一步降低运算量首先对图片进行二值化处理并完成边检测。对处理后的结果再

  进行 Hough 变换。

- 轮廓检测（ contours）

  对于一些更为复杂的形状检测，OpenCV 提供的轮廓检测函数 findContours()及轮廓处理函数 drawContours()来 进行检测和识别。该检测函数主要针对二值图像，因此，在函数调用之前需要采用 threshold()函数 对图片进行二值化处理，下面是一个轮廓检测的例子。

2. 图片形状检测 31

![](Aspose.Words.b353301d-f3c7-44fc-a0ef-0183eb531768.063.png)
| cnt = contours[0]                  |
| ---------------------------------- |
|                                    |
|                                    |
|                                    |
| #the moment return a dic           |
|                                    |
| M = cv.moments(cnt)                |
|                                    |
| print( M )                         |
|                                    |
|                                    |
| -                                  |
| the centric of the contour         |
|                                    |
| cx = int(M[' m10' ]/M[ ' m00' ])   |
|                                    |
| cy = int(M[' m01' ]/M[ ' m00' ])   |
|                                    |
|                                    |
| -                                  |
| the area of the contour            |
|                                    |
| area = cv.contourArea(cnt)         |
|                                    |
|                                    |
| -                                  |
| the Perimeter of the contour       |
|                                    |
| perimeter = cv.arcLength(cnt,True) |

<a name="_page36_x72.00_y64.23"></a>图 4.3: 直线的 Hough 变换 [^2]

![](Aspose.Words.b353301d-f3c7-44fc-a0ef-0183eb531768.064.jpeg)

<a name="_page36_x72.00_y272.91"></a>图 4.4: 圆形 Hough 变换 [3 ](#_page123_x72.00_y276.42)contours,hierarchy = cv.findContours(thresh, 1, 2)

1 2

32 第四章 OPENCV 基础

界被识别出来后通常用一个标准的形状（矩形、圆形、椭圆等）来标识轮廓。OpenCV 中也提供了相 应的 moments()、contourArea()、arcLength()函数来计算轮廓的相关参量。
